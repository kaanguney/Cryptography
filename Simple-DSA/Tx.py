import randomimport pyprimesimport warningsfrom Crypto.Hash import SHA3_256# create signatures heredef SignatureGenerator(m,alpha,q,p,g):    hashval = SHA3_256.new() # create new SHA object here    hashval.update(m) # hash here    hold = hashval.digest()    h = int.from_bytes(hold, byteorder='big') # conversion from bytes to integer    k = random.randint(1,q-2)    r = pow(g,k,p) % q    s = ((alpha*r)-(k*h)) % q    return s,r # returning as a tuple or by comma is essentially the same thing post-function call# generate public parameter for transactiondef PublicParamGenerator(q,p,g):    alpha = random.randint(1,q-2) # private    beta = pow(g,alpha,p) # public    return alpha, beta# return serial number# generates random 128-bit integer which is the serial numberdef SerialNum():    j = random.getrandbits(128)    return j# checks if public keys are secure for transaction#we decided not to use this function since it's for very small probabilitiesdef CheckPublicKeys(payer_beta,payee_beta):    # returns True if public keys are not the same -> DS is secure,else returns False    if(payer_beta != payee_beta):        return 1    return 0# inputs the public parameters and returns bitcoin transaction infodef gen_random_tx(q,p,g):    btc = ""    serialnum = SerialNum() # serial number, 128-bit integer for the transaction    payer_alpha, payer_beta = PublicParamGenerator(q,p,g) # public parameters of the transaction -> payer    payee_alpha, payee_beta = PublicParamGenerator(q,p,g) # public parameters of the transaction -> payee    # identification is done by appropriate public-key generation and then it's signed by the private key of the payer    # assign the transaction amount    satoshi = random.randint(1, 1000000)    btc = "*** Bitcoin transaction *** \n  Serial number: " + str(serialnum) + "\n Payer public key (beta): " + str(payer_beta) + "\n Payee public key (beta): " + str(payee_beta) + "\n Amount: " + str(satoshi) + "\n"    # get the signatures now, pass payer_alpha for signature becasue payer signs the transaction    BytesBtc = str.encode(btc)    s,r = SignatureGenerator(BytesBtc,payer_alpha,q,p,g)    btc = btc + "Signature (s): " + str(s) + "\n Signature (r): " + str(r)    # transaction info filled    return btc